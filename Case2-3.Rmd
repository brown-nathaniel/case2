---
title: "Untitled"
author: "Nathaniel Brown, In Hee Ho, Sarah Zimmermann"
date: "October 19, 2017"
output:
  pdf_document: default
  html_document: default
---

```{r, warning=FALSE, echo=FALSE, message=FALSE}
set.seed(440)
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message=FALSE)
library(knitr)
library(ggplot2)
library(survival)
library(gridExtra)
library(dplyr)
library(survminer)
library(reshape2)
library(glmnet)
library(arm)
library(mice)
```

```{r}
dat <- read.table("kellydat.txt", header=T)
dat$race = "Other"
dat$race[dat$black==1|dat$hisp==1 ]="Black or Hispanic"
dat$gender = "male"
dat$gender[dat$male==0]="female"
dat$symptom = "0"
dat$symptom[dat$sn1==1]="1"
dat$symptom[dat$sn2==1]="2"
dat$symptom[dat$sn3==1|dat$all4==1]="3+"
dat$scan="not scanned"
dat$scan[dat$fail==1]="scanned"
dat = dat %>% group_by(race) %>% mutate(racescan = ifelse(fail == 1, mean(fail), 1-mean(fail)))
dat = dat %>% group_by(symptom) %>% mutate(symptomscan = ifelse(fail == 1, mean(fail), 1-mean(fail)))
dat = dat %>% group_by(gender) %>% mutate(genderscan = ifelse(fail == 1, mean(fail), 1-mean(fail))) %>% as.data.frame()
```


```{r logitfunctions}
#all the functions

lower_bound <- function(x, bounds){
  ret <- rep(NA, length(x))
  for(i in 1:length(x)){
    xi <- x[i]
    found <- (which(xi >= c(-Inf, bounds) & (xi <= c(bounds, Inf))))[1] - 1
    if(found==0){found<-1}
    ret[i] <- bounds[found]
  }
  return(ret)
}

de_logit <- function(logodds){
  o <- exp(logodds)
  p <- o/(1+o)
  return(p)
}

#transform continuous time (nctdel) into categries based on lower bounds of "bounds" variable
categorize_dat <- function(dat=NA, bounds=NA){

  dat$timecat <- as.integer(as.factor(lower_bound(dat$nctdel, bounds)))
  dat$personid <- 1:nrow(dat)
  datcat <- merge(dat$personid, bounds) %>% 
          mutate(personid=x, timecat=as.integer(as.factor(y))) %>%
            #take all unique combinations of people and time categories
          merge(dat, by=c("personid", "timecat"), all=TRUE) %>%
          mutate(fail = ifelse(is.na(fail), 0, fail)) %>%
            #add fail column
          group_by(personid) %>%
          mutate(maxtimecat = (timecat)[!is.na(nctdel)],
                 atrisk = (timecat <= maxtimecat)) %>%
          filter(atrisk) %>%
            #for each person, identify rows where persons are not at risk (after they fail/drop out), and remove those rows
          dplyr::select(personid, timecat, fail) %>%
          as.data.frame()

#code to add predictors of race, gender, and number of symptoms
  datcat <- merge(datcat, dat, by="personid", all=T) %>% 
          mutate(symptom0 = ifelse(symptom == 0, 1, 0),
                 symptom1 = ifelse(symptom == 1, 1, 0),
                 symptom2 = ifelse(symptom == 2, 1, 0),
                 raceother = ifelse(race == "Other", 1, 0), 
                 male = ifelse(gender == "male", 1, 0), 
                 personid = as.integer(personid), 
                 timecat = as.integer(timecat.x), 
                 fail = as.integer(fail.x)) %>% 
          dplyr::select(personid, timecat = timecat, fail = fail, symptom0, symptom1, symptom2, raceother, male)

#code to add indicator effects of every timeunit
  Xmat <- array(0, c(nrow(datcat), length(bounds)))

  for(r in 1:nrow(datcat)){
    Xmat[r,datcat$timecat[r]] <- 1
  }

  colnames(Xmat) <- paste0("X",1:ncol(Xmat))


  datcat_X <- (cbind((datcat), Xmat))

  datcat_X$nctdel <- merge(datcat_X, dat, by="personid", all=TRUE)$nctdel
  
  return(datcat_X)
}

#obtain fitted values, pearson residuals, deviance residuals, and other diagnostic tools
logistic_diagnostics <- function(mod=NA, ydat=y, Xdat=X){
  
  if(class(mod)[1] == "cv.glmnet"){
    fitvals <- predict.cv.glmnet(mod, newx = Xdat, s="lambda.min")
  }else{
    fitvals <- predict.glm(mod, newdata=data.frame(Xdat))
  }
  p_hat <- de_logit(fitvals)
  resids_p <- (ydat-p_hat)/(sqrt(p_hat*(1-p_hat)))
  s <- ydat; s[ydat==0] <- -1
  resids_d <- s*sqrt(-2*(ydat*log(p_hat) + (1-ydat)*log(1-p_hat)))
  resids_p_stat <- sum(resids_p^2)
  resids_d_stat <- -2*sum(ydat*log(p_hat) + (1-ydat)*log(1-p_hat))
  p <- sum(as.matrix(coef(mod)) != 0 | is.na(as.matrix(coef(mod))))
  dof <- nrow(Xdat)-p
  return(list(p_hat = p_hat, resids_p=resids_p, resids_p_stat=resids_p_stat, resids_d=resids_d, resids_d_stat=resids_d_stat, dof=dof))
}

#obtain confidence intervals for coefficients (for glm object)
logistic_conf <- function(mod){
  stats <- summary(mod)$coefficients
  xbar <- stats[,1]
  sigma <- stats[,2]
  logmodcoef <- xbar + 1.96*cbind(-sigma, sigma)
  logmodcoef <- round(logmodcoef,4)
  colnames(logmodcoef) <- c("Lower", "Upper")
  return(logmodcoef)
}

#reshape categorized timebins into a specified number of kernels
kernel_transformation <- function(datcat, bounds, kernels, s=NA) {

  Ks <- array(NA, c(nrow(datcat), kernels))
  colnames(Ks) <- paste0("k", 1:kernels)
  datcat <- datcat[,!startsWith(colnames(datcat), "X")]
  datcat_k <- cbind(datcat, Ks)
  kcols <- (ncol(datcat_k) - kernels + 1):ncol(datcat_k)
  
  tau <- seq(from=1, to=max(bounds), length.out = kernels)
  if(is.na(s)){
    s <- (tau[2]-tau[1])/2
  }
  # each row is one bin, the columns are the kernel weights for that bin
  kernel.weights <- matrix(dnorm(x=rep(1:length(bounds),kernels),mean=rep(tau,each=length(bounds)),s), ncol=kernels)

  for(p in unique(datcat$personid)){
    subrows <- which(datcat$personid == p)
    time <- max(datcat$timecat[subrows])

    K <- array(kernel.weights[1:time,],dim=c(time,kernels))
    datcat_k[subrows,kcols] <- K
  }
  #datcat_k <- cbind(datcat, K)
  # X has kernel weights instead of the bin indicators that it had before
   return(as.data.frame(datcat_k))
}


```

```{r logitanalysis}
#all the analysis

bounds <- 0:5
datcat_X <- categorize_dat(dat, bounds)
indepcols <- which(!colnames(datcat_X) %in% c("fail", "personid", "timecat", "nctdel"))
X <- as.matrix(datcat_X[,indepcols])
y <- datcat_X$fail

kernels <- 2
datcat_Xk <- kernel_transformation(datcat_X, bounds, kernels, s=NA)
indepcolsk <- which(!colnames(datcat_Xk) %in% c("fail", "personid", "timecat", "nctdel"))
Xk <- as.matrix(datcat_Xk[,indepcolsk])
yk <- datcat_Xk$fail

nullmod <- glm(fail ~ 1, data=datcat_X, family="binomial")
nullmod_stats <- logistic_diagnostics(nullmod)
nullmod_test <- pchisq(nullmod$deviance, nullmod$df.residual, lower=FALSE)

logmod <- glm(y ~ 0 + ., family="binomial", data = as.data.frame(cbind(y,X))) #0 means no incercept
logmod_stats <- logistic_diagnostics(logmod)
logmod_test <- pchisq(logmod$deviance, logmod$df.residual, lower=FALSE)
logmod_coef <- logistic_conf(logmod)

lassomod <- cv.glmnet(y=y, x = X, family="binomial", type.measure="class", alpha = 1, intercept=FALSE)
lassomod_stats <- logistic_diagnostics(lassomod)
lassomod_test <- pchisq(lassomod_stats$resids_d_stat, lassomod_stats$dof, lower=FALSE)
lassomod_coef <- round(as.matrix(coef(lassomod)),4)
colnames(lassomod_coef) <- "LASSO Estimate"

ridgemod <- cv.glmnet(y=y, x = X, family="binomial", type.measure="class", alpha = 0,intercept=FALSE)
ridgemod_stats <- logistic_diagnostics(ridgemod)
ridgemod_test <- pchisq(ridgemod_stats$resids_d_stat, ridgemod_stats$dof, lower=FALSE)
ridgemod_coef <- round(as.matrix(coef(ridgemod)),4)
colnames(ridgemod_coef) <- "Ridge Estimate"

kernelmod <- glm(yk ~ 0 + .,  data = as.data.frame(cbind(yk,Xk)), family="binomial")
kernelmod_stats <- logistic_diagnostics(kernelmod, yk, Xk)
kernelmod_test <- pchisq(kernelmod_stats$resids_d_stat, kernelmod_stats$dof, lower=FALSE)
kernelmod_coef <- logistic_conf(kernelmod)

```


```{r}
binnedplot(x=logmod$fitted.values, y=logmod_stats$resids_d, main = "OLS Logistic Regression Binned Residuals", ylab = "Deviance Residuals", xlab = "Fitted Values", nclass = 50)
```

```{r}
binnedplot(x=lassomod_stats$p_hat, y=lassomod_stats$resids_d, main = "LASSO Logistic Regression Binned Residuals", ylab = "Deviance Residuals", xlab = "Fitted Values", nclass = 50)
```

```{r}
binnedplot(x=ridgemod_stats$p_hat, y=ridgemod_stats$resids_d, main = "Ridge Logistic Regression Binned Residuals", ylab = "Deviance Residuals", xlab = "Fitted Values", nclass = 50)
```


```{r}
binnedplot(x=kernelmod_stats$p_hat, y=kernelmod_stats$resids_d, main = "Kernel Logistic Regression Binned Residuals", ylab = "Deviance Residuals", xlab = "Fitted Values", nclass = 50)
```

```{r}
d <- round(matrix(c(logmod_test, lassomod_test, ridgemod_test, kernelmod_test)),4)
colnames(d) <- "Deviance p-value"
rownames(d) <- c("OLS", "LASSO Penalty", "Ridge Penalty", "Kernels")

kable(d)
kable(logmod_coef)
kable(lassomod_coef)
kable(ridgemod_coef)
kable(kernelmod_coef)
```




```{r}
# sampleGibbs <- function(start.a, start.b, n.sims, data){
#   # get sum, which is sufficient statistic
#   x <- sum(data, na.rm=TRUE)
#   # get n
#   n <- nrow(data)
#   # create empty matrix, allocate memory for efficiency
#   res <- matrix(NA, nrow = n.sims, ncol = 2)
#   res[1,] <- c(start.a,start.b)
#   for (i in 2:n.sims){
#     # sample the values
#     res[i,1] <- rgamma(1, shape = n+1,
#     rate = res[i-1,2]*x+1)
#     res[i,2] <- rgamma(1, shape = n+1,
#     rate = res[i,1]*x+1)
#   }
#   return(res)
# }
# 
# # run Gibbs sampler
# n.sims <- 10000
# res <- sampleGibbs(.25,.25,n.sims,data)
# head(res)
# 
# d <- as.matrix(log(dat$nctdel+0.01))
# result <- sampleGibbs(1,1,n.sims,d)
```

```{r}
data <- read.table("kellydat.txt", header=T)
data$race = 0
data$race[data$black==1|data$hisp==1] = 1
data$sn0 = 0
data$sn0[data$sn1==0 & data$sn2==0 & data$sn3==0 & data$all4==0] = 1

data.imp = data
data.imp$nctdel[data.imp$fail == 0] = NA

#md.pattern(data.imp[!is.na(data.imp$nctdel),])

tempData <- mice(data.imp,m=5,maxit=50,meth='pmm',seed=500, print=FALSE)
# methods: 
# 2l.norm / 2l.pan / 2lonly.mean / 2lonly.norm / 2lonly.pmm / 
# cart / fastpmm / lda / logreg / logreg.boot / mean / midastouch / norm / norm.boot / norm.nob / 
# norm.predict / passive / pmm / polr / polyreg / quadratic / rf / ri / sample

#tempData$imp$nctdel

data.imp <- complete(tempData)

hist(log(data.imp$nctdel + 0.1))

fit <-lm(log(nctdel+0.1) ~ sn0 + sn1 + sn2 + race + male, data = data)
```
##Assumptions
```{r}
library(VIM)
library(mice)


##looking for pattern of missing data
md.pattern(data.imp)

#visualizations: 
aggr_plot <- aggr(data, col=c('navyblue','red'), numbers=TRUE, sortVars=TRUE, labels=names(data), cex.axis=.7, gap=3, ylab=c("Histogram of missing data","Pattern"))

marginplot(data.imp[c(1,2)])
marginplot(data[c(1,3)])
marginplot(data[c(1,4)])
marginplot(data[c(1,5)])
marginplot(data[c(1,6)])
marginplot(data[c(1,7)])
marginplot(data[c(1,8)])
marginplot(data[c(1,9)])
marginplot(data[c(1,10)])



#visualize distribution of original and imputed data- check if imputed data is plausible

#xyplot(tempData,nctdel ~ fail+male+black,pch=18,cex=1)  

#densityplot(tempData)

#stripplot(data, pch = 20, cex = 1.2)
```



# Survival Curves: 
##Question for Jonathan: how do we plot a survival curve from glm???

```{r}
#survival to time t = p(x>t);
get_timecat_hazards <- function(mod){
  coefs <- as.matrix(coef(mod))
  invlogit(coefs[which(startsWith(rownames(coefs),"X")),])
}

#calculate the hazards of each time category (kernels are a little more complicated)
logmod_hazards <- get_timecat_hazards(logmod)
lassomod_hazards <- get_timecat_hazards(lassomod)
ridgemod_hazards <- get_timecat_hazards(ridgemod)

get_timecat_survival <- function(mod_hazards){
  p <- s <- NULL
  for(t in 1:length(mod_hazards)){

    #h_1 <- p(x=1)/p(x>=1) = p(x=1)
    #h_2 <- p(x=2)/p(x>=2) = p(x=2)/(1-h_1)
    #h_3 <- p(x=3)/p(x>=3) = p(x=3)/[(1-h_1)(1-h_2)]
  
    #h_t <- p(x=t)/[(1-h_1)(1-h_2)...(1-h_(t-1))] ==> p(x=t) = h_t(1-h_1)(1-h_2)...(1-h_(t-1))
      p[t] <- prod(1-mod_hazards[0:(t-1)])*mod_hazards[t]
  #calculate discrete pdf
  
    #put the p(x=1), p(x=2)...all together

  #calculate survival by summing pdf bins
  
    #s(t) = sum(pdf) from 0 to t
  }
  s <- 1-cumsum(p)
  return(list(pmf=p, surv=s))
}

logmod_surv <- get_timecat_survival(logmod_hazards)
lassomod_surv <- get_timecat_survival(lassomod_hazards)
ridgemod_surv <- get_timecat_survival(ridgemod_hazards)

plot(x=1:length(logmod_surv[[2]]), y=logmod_surv[[2]], type="s")
plot(x=1:length(lassomod_surv[[2]]), y=lassomod_surv[[2]], type="s")
plot(x=1:length(ridgemod_surv[[2]]), y=ridgemod_surv[[2]], type="s")
```

```{r}
#kernel survival curve 
bounds=c(0,1,2,3,4,5)
kernels=2
tau <- seq(from=1, to=max(bounds), length.out = kernels)
s <- (tau[2]-tau[1])/2
kernel.weights <- matrix(dnorm(x=rep(1:length(bounds),kernels),mean=rep(tau,each=length(bounds)),s), ncol=kernels)

kernel.weights_1= data.frame(kernel.weights, rep(-0.73895618, 6), rep(-0.35687333, 6), rep(-0.44156633), rep(0.05489664 ,6), rep(-0.25308262, 6) )

colnames= c("k1", "k2", "symptom0", "symptom1", "symptom2", "raceother", "male")

colnames(kernel.weights_1)= colnames

x= predict(kernelmod, kernel.weights_1)



kernel_surv= get_timecat_survival(invlogit(x))
plot(x=1:length(logmod_surv[[2]]), y=logmod_surv[[2]], type="s")
```


```{r}
plot(survfit(Surv(timecat, fail) ~ raceother + male, data = datcat_X), 
     main=expression(paste("Kaplan-Meier Estimate ", hat(S)(t), " with CI")),xlab="t", ylab="Survival", lwd=2)
```

```{r}
plot(survfit(Surv(timecat, fail) ~ raceother + male, data=datcat_X) , xlab="Survival Time", 
  ylab="% Surviving", yscale=100, col=c("red","blue", "black", "green"),
  main="Survival Distributions") 
  legend("topright", title="Legend", c("Black/Hisp", "Non Black/Hisp" ,"Male", "Female"),
  fill=c("red", "blue", "black", "green"))
  
  survdiff(Surv(timecat, fail) ~ raceother + male, data=datcat_X)
```

# Discussion

why nothing is significant:

```{r}
#this is not actually part of the report as of right now
dat$lnctdel <- log(dat$nctdel+0.01)
dat %>% filter(nctdel < quantile(nctdel,0.95) & fail == 1) %>% group_by(symptom) %>% summarize(mean = mean(nctdel), n = n(), sd = sd(nctdel)) %>% mutate(lower = (mean - 1.96*sd/sqrt(n)), upper = (mean + 1.96*sd/sqrt(n))) 

dat %>% filter(nctdel < quantile(nctdel,0.95) & fail == 1) %>% group_by(gender) %>% summarize(mean = mean(nctdel), median = median(nctdel))

dat %>% filter(nctdel < quantile(nctdel,0.95) & fail == 1) %>% group_by(race) %>% summarize(mean = mean(nctdel), median = median(nctdel))

```

#References 

https://www.r-bloggers.com/imputing-missing-data-with-r-mice-package/