---
title: "Untitled"
author: "Nathaniel Brown, In Hee Ho, Sarah Zimmermann"
date: "October 19, 2017"
output: html_document
---

```{r, warning=FALSE, echo=FALSE, message=FALSE}
set.seed(440)
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message=FALSE)
library(knitr)
library(ggplot2)
library(survival)
library(gridExtra)
library(dplyr)
library(survminer)
library(reshape2)
library(glmnet)
library(arm)
library(mice)
```

```{r}
dat <- read.table("kellydat.txt", header=T)
dat$race = "Other"
dat$race[dat$black==1|dat$hisp==1 ]="Black or Hispanic"
dat$gender = "male"
dat$gender[dat$male==0]="female"
dat$symptom = "0"
dat$symptom[dat$sn1==1]="1"
dat$symptom[dat$sn2==1]="2"
dat$symptom[dat$sn3==1|dat$all4==1]="3+"
dat$scan="not scanned"
dat$scan[dat$fail==1]="scanned"
dat = dat %>% group_by(race) %>% mutate(racescan = ifelse(fail == 1, mean(fail), 1-mean(fail)))
dat = dat %>% group_by(symptom) %>% mutate(symptomscan = ifelse(fail == 1, mean(fail), 1-mean(fail)))
dat = dat %>% group_by(gender) %>% mutate(genderscan = ifelse(fail == 1, mean(fail), 1-mean(fail))) %>% as.data.frame()
```


```{r logit}

lower_bound <- function(x, bounds){
  ret <- rep(NA, length(x))
  for(i in 1:length(x)){
    xi <- x[i]
    found <- (which(xi >= c(-Inf, bounds) & (xi <= c(bounds, Inf))))[1] - 1
    if(found==0){found<-1}
    ret[i] <- bounds[found]
  }
  return(ret)
}

de_logit <- function(logodds){
  o <- exp(logodds)
  p <- o/(1+o)
  return(p)
}

bounds <- 0:5

categorize_dat <- function(dat=NA, bounds=NA){

  dat$timecat <- as.integer(as.factor(lower_bound(dat$nctdel, bounds)))
  dat$personid <- 1:nrow(dat)
  datcat <- merge(dat$personid, bounds) %>% 
          mutate(personid=x, timecat=as.integer(as.factor(y))) %>%
            #take all unique combinations of people and time categories
          merge(dat, by=c("personid", "timecat"), all=TRUE) %>%
          mutate(fail = ifelse(is.na(fail), 0, fail)) %>%
            #add fail column
          group_by(personid) %>%
          mutate(maxtimecat = (timecat)[!is.na(nctdel)],
                 atrisk = (timecat <= maxtimecat)) %>%
          filter(atrisk) %>%
            #for each person, identify rows where persons are not at risk (after they fail/drop out), and remove those rows
          dplyr::select(personid, timecat, fail) %>%
          as.data.frame()

#code to add predictors of race, gender, and number of symptoms
  datcat <- merge(datcat, dat, by="personid", all=T) %>% 
          mutate(symptom0 = ifelse(symptom == 0, 1, 0),
                 symptom1 = ifelse(symptom == 1, 1, 0),
                 symptom2 = ifelse(symptom == 2, 1, 0),
                 raceother = ifelse(race == "Other", 1, 0), 
                 male = ifelse(gender == "male", 1, 0), 
                 personid = as.integer(personid), 
                 timecat = as.integer(timecat.x), 
                 fail = as.integer(fail.x)) %>% 
          dplyr::select(personid, timecat = timecat, fail = fail, symptom0, symptom1, symptom2, raceother, male)

#code to add indicator effects of every timeunit
  Xmat <- array(0, c(nrow(datcat), length(bounds)))
# previd <- NA
# changes <- c(diff(datcat$personid), 1) #a 1 marks the final index of each personid
# counts <- data.frame(x = datcat$personid) %>% group_by(x) %>% mutate(n=n()) %>% '[['("n")

  for(r in 1:nrow(datcat)){
    Xmat[r,datcat$timecat[r]] <- 1
  }

  colnames(Xmat) <- paste0("X",1:ncol(Xmat))


  datcat_X <- (cbind((datcat), Xmat))

  datcat_X$nctdel <- merge(datcat_X, dat, by="personid", all=TRUE)$nctdel
  
  return(datcat_X)
}

datcat_X <- categorize_dat(dat, bounds)

nullmod <- glm(fail ~ 1, data=datcat_X, family="binomial")

logistic_diagnostics <- function(mod=NA, ydat=y, Xdat=X){
  
  if(class(mod)[1] == "cv.glmnet"){
    fitvals <- predict.cv.glmnet(mod, newx = Xdat, s="lambda.min")
  }else{
    fitvals <- predict.glm(mod, newdata=data.frame(Xdat))
  }
  p_hat <- de_logit(fitvals)
  resids_p <- (ydat-p_hat)/(sqrt(p_hat*(1-p_hat)))
  s <- ydat; s[ydat==0] <- -1
  resids_d <- s*sqrt(-2*(ydat*log(p_hat) + (1-ydat)*log(1-p_hat)))
  resids_p_stat <- sum(resids_p^2)
  resids_d_stat <- -2*sum(ydat*log(p_hat) + (1-ydat)*log(1-p_hat))
  p <- sum(as.matrix(coef(mod)) != 0 | is.na(as.matrix(coef(mod))))
  dof <- nrow(Xdat)-p
  return(list(p_hat = p_hat, resids_p=resids_p, resids_p_stat=resids_p_stat, resids_d=resids_d, resids_d_stat=resids_d_stat, dof=dof))
}

indepcols <- which(!colnames(datcat_X) %in% c("fail", "personid", "timecat", "nctdel"))
X <- as.matrix(datcat_X[,indepcols])
y <- datcat_X$fail

#0 means no incercept
logmod <- glm(y ~ 0 + ., family="binomial", data = as.data.frame(cbind(y,X)))
logmod_stats <- logistic_diagnostics(logmod)
logmodtest <- pchisq(logmod$deviance, logmod$df.residual, lower=FALSE)

lassomod <- cv.glmnet(y=y, x = X, family="binomial", type.measure="class", alpha = 1, intercept=FALSE)
lassomod_stats <- logistic_diagnostics(lassomod)
lassomodtest <- pchisq(lassomod_stats$resids_d_stat, lassomod_stats$dof, lower=FALSE)

ridgemod <- cv.glmnet(y=y, x = X, family="binomial", type.measure="class", alpha = 0,intercept=FALSE)
ridgemod_stats <- logistic_diagnostics(ridgemod)
ridgemodtest <- pchisq(ridgemod_stats$resids_d_stat, ridgemod_stats$dof, lower=FALSE)
```


```{r}
bounds <- 1:floor(max(dat$nctdel))
datcat_X2 <- categorize_dat(dat, bounds)
indepcols2 <- which(!colnames(datcat_X2) %in% c("fail", "personid", "timecat", "nctdel"))
X2 <- as.matrix(datcat_X2[,indepcols2])
y2 <- datcat_X2$fail



#0 means no incercept
logmod2 <- glm(y2 ~ 0 + ., family="binomial", data = as.data.frame(cbind(y2,X2)))

beta <- coef(logmod2)
hazard <- exp(beta)/(1+exp(beta))
plot(bounds, hazard[startsWith(names(hazard), "X")], type='l')

# this is pretty ugly. Let's smooth it out with kernel regression.

# set up the kernels
kernels <- 2


# now we'll create a new transform function
kernel_transformation <- function(datcat, bounds, kernels, s=NA) {

  Ks <- array(NA, c(nrow(datcat), kernels))
  colnames(Ks) <- paste0("k", 1:kernels)
  datcat <- datcat[,!startsWith(colnames(datcat), "X")]
  datcat_k <- cbind(datcat, Ks)
  kcols <- (ncol(datcat_k) - kernels + 1):ncol(datcat_k)
  
  tau <- seq(from=1, to=max(bounds), length.out = kernels)
  s <- (tau[2]-tau[1])/2
  
  # each row is one bin, the columns are the kernel weights for that bin
  kernel.weights <- matrix(dnorm(x=rep(1:length(bounds),kernels),mean=rep(tau,each=length(bounds)),s), ncol=kernels)

  for(p in unique(datcat$personid)){
    subrows <- which(datcat$personid == p)
    time <- max(datcat$timecat[subrows])

    K <- array(kernel.weights[1:time,],dim=c(time,kernels))
    datcat_k[subrows,kcols] <- K
  }
  #datcat_k <- cbind(datcat, K)
  # X has kernel weights instead of the bin indicators that it had before
   return(as.data.frame(datcat_k))
}

datcat_X3 <- kernel_transformation(datcat_X, bounds, 4)
indepcols3 <- which(!colnames(datcat_X3) %in% c("fail", "personid", "timecat", "nctdel"))
X3 <- as.matrix(datcat_X3[,indepcols3])
y3 <- datcat_X3$fail

# fit a model

m3 <- glm(y3 ~ 0 + .,  data = as.data.frame(cbind(y3,X3)), family="binomial")
summary(m3)

# make a smooth plot


# hazard.logodds <- predict(m3, newdata = data.frame(kernel.weights))
# hazard <- exp(hazard.logodds)/(1+exp(hazard.logodds))
# plot(1:total_bins, hazard, type='l')

kernelmod_stats <- logistic_diagnostics(m3, y3, X3)
kernelmodtest <- pchisq(kernelmod_stats$resids_d_stat, kernelmod_stats$dof, lower=FALSE)

```



```{r}
#evaluating deviance of models. small p-value = lack of fit
#par((mfrow = c(3,1)))

stats <- summary(logmod)$coefficients
xbar <- stats[,1]
sigma <- stats[,2]
logmodcoef <- xbar + 1.96*cbind(-sigma, sigma)
logmodcoef <- round(logmodcoef,4)
colnames(logmodcoef) <- c("Lower", "Upper")
binnedplot(x=logmod$fitted.values, y=logmod_stats$resids_d, main = "OLS Logistic Regression Binned Residuals", ylab = "Deviance Residuals", xlab = "Fitted Values", nclass = 50)
```

```{r}
lassomodcoef <- round(as.matrix(coef(lassomod)),4)
colnames(lassomodcoef) <- "LASSO Estimate"
binnedplot(x=lassomod_stats$p_hat, y=lassomod_stats$resids_d, main = "LASSO Logistic Regression Binned Residuals", ylab = "Deviance Residuals", xlab = "Fitted Values", nclass = 50)
```

```{r}
ridgemodcoef <- round(as.matrix(coef(ridgemod)),4)
colnames(ridgemodcoef) <- "Ridge Estimate"
binnedplot(x=ridgemod_stats$p_hat, y=ridgemod_stats$resids_d, main = "Ridge Logistic Regression Binned Residuals", ylab = "Deviance Residuals", xlab = "Fitted Values", nclass = 50)
```

```{r}
d <- round(matrix(c(logmodtest, lassomodtest, ridgemodtest)),4)
colnames(d) <- "Deviance p-value"
rownames(d) <- c("OLS", "LASSO Penalty", "Ridge Penalty")

kable(d)
kable(logmodcoef)
kable(lassomodcoef)
kable(ridgemodcoef)

```




```{r}
sampleGibbs <- function(start.a, start.b, n.sims, data){
# get sum, which is sufficient statistic
x <- sum(data)
# get n
n <- nrow(data)
# create empty matrix, allocate memory for efficiency
res <- matrix(NA, nrow = n.sims, ncol = 2)
res[1,] <- c(start.a,start.b)
for (i in 2:n.sims){
# sample the values
res[i,1] <- rgamma(1, shape = n+1,
rate = res[i-1,2]*x+1)
res[i,2] <- rgamma(1, shape = n+1,
rate = res[i,1]*x+1)
}
return(res)
}

# run Gibbs sampler
n.sims <- 10000
res <- sampleGibbs(.25,.25,n.sims,data)
head(res)
```

```{r}
data <- read.table("kellydat.txt", header=T)
data$race = 0
data$race[data$black==1|data$hisp==1] = 1
data$sn0 = 0
data$sn0[data$sn1==0 & data$sn2==0 & data$sn3==0 & data$all4==0] = 1

data.imp = data
data.imp$nctdel[data.imp$fail == 0] = NA

md.pattern(data.imp[!is.na(data.imp$nctdel),])


tempData <- mice(data.imp,m=5,maxit=50,meth='pmm',seed=500)
# methods: 
# 2l.norm / 2l.pan / 2lonly.mean / 2lonly.norm / 2lonly.pmm / 
# cart / fastpmm / lda / logreg / logreg.boot / mean / midastouch / norm / norm.boot / norm.nob / 
# norm.predict / passive / pmm / polr / polyreg / quadratic / rf / ri / sample

tempData$imp$nctdel

data.imp <- complete(tempData)

hist(log(data.imp$nctdel + 0.1))

fit <-lm(log(nctdel+0.1) ~ sn0 + sn1 + sn2 + race + male, data = data)
```