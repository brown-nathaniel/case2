datcat <- merge(datcat, dat, by="personid", all=T) %>% select(personid, timecat = timecat.x, fail = fail.x, symptom = as.factor(symptom), race = as.factor(race), gender = as.factor(gender))
head()
head(dat)
bounds <- seq(0, floor(max(dat$nctdel)))
dat$timecat <- lower_bound(dat$nctdel, bounds)
dat$personid <- 1:nrow(dat)
datcat <- merge(dat$personid, bounds) %>%
unique() %>%
rename(personid=x, timecat=y) %>%
arrange(personid, timecat) %>%
#take all unique combinations of people and time categories
merge(dat, by=c("personid", "timecat"), all=TRUE) %>%
mutate(fail = ifelse(is.na(fail), 0, fail)) %>%
#add fail column
group_by(personid) %>%
mutate(maxtimecat = (timecat)[!is.na(nctdel)],
atrisk = (timecat <= maxtimecat)) %>%
filter(atrisk) %>%
#for each person, identify rows where persons are not at risk (after they fail/drop out), and remove those rows
select(personid, timecat, fail) %>%
as.data.frame()
#code to add predictors of race, gender, and number of symptoms
datcat <- merge(datcat, dat, by="personid", all=T) %>% select(personid, timecat = timecat.x, fail = fail.x, symptom = as.factor(symptom), race = as.factor(race), gender = as.factor(gender))
lower_bound <- function(x, bounds){
ret <- rep(NA, length(x))
for(i in 1:length(x)){
xi <- x[i]
found <- (which(xi >= c(-Inf, bounds) & (xi <= c(bounds, Inf))))[1] - 1
if(found==0){found<-1}
ret[i] <- bounds[found]
}
return(ret)
}
bounds <- seq(0, floor(max(dat$nctdel)))
dat$timecat <- lower_bound(dat$nctdel, bounds)
dat$personid <- 1:nrow(dat)
datcat <- merge(dat$personid, bounds) %>%
unique() %>%
rename(personid=x, timecat=y) %>%
arrange(personid, timecat) %>%
#take all unique combinations of people and time categories
merge(dat, by=c("personid", "timecat"), all=TRUE) %>%
mutate(fail = ifelse(is.na(fail), 0, fail)) %>%
#add fail column
group_by(personid) %>%
mutate(maxtimecat = (timecat)[!is.na(nctdel)],
atrisk = (timecat <= maxtimecat)) %>%
filter(atrisk) %>%
#for each person, identify rows where persons are not at risk (after they fail/drop out), and remove those rows
select(personid, timecat, fail) %>%
as.data.frame()
#code to add predictors of race, gender, and number of symptoms
datcat <- merge(datcat, dat, by="personid", all=T) %>%
mutate(symptom = as.factor(symptom), race = as.factor(race), gender = as.factor(gender)) %>%
select(personid, timecat = timecat.x, fail = fail.x, symptom, race, gender)
#code to add indicator effects of every timeunit
Xmat <- array(0, c(nrow(datcat), length(bounds)))
previd <- NA
changes <- c(diff(datcat$personid), 1) #a 1 marks the final index of each personid
counts <- data.frame(x = datcat$personid) %>% group_by(x) %>% mutate(n=n()) %>% '[['("n")
for(r in 1:nrow(datcat)){
if(datcat$fail[r] == 1 & changes[r] == 1){
Xmat[r,counts[r]] <- 1
}
}
colnames(Xmat) <- paste0("X",1:ncol(Xmat))
datcat <- cbind(datcat, Xmat)
# ids <- c(229)
# dat %>% filter(personid %in% ids) %>% select(personid, timecat, fail)
# datcat %>% filter(personid %in% ids)
logreg1 <- glm(fail ~ . - personid, data=datcat, family="binomial") #does not converge
indepcols <- which(!colnames(datcat) %in% c("fail", "personid"))
lassoreg1 <- glmnet(y=datcat$fail, x = datcat[,indepcols], family="binomial", alpha = 1)
typeof(datcat$symptom)
typeof(datcat$gender)
typeof(datcat$race)
unique(datcat$race)
head(datcat)
typeof(datcat$fail)
typeof(datcat[,indepcols])
typeof(datcat[,2])
typeof(datcat[,c(2,3)])
typeof(as.matrix(datcat[,indepcols]))
apply(datcat, 2, typeof())
apply(datcat, 2, typeof)
bounds <- seq(0, floor(max(dat$nctdel)))
dat$timecat <- lower_bound(dat$nctdel, bounds)
dat$personid <- 1:nrow(dat)
datcat <- merge(dat$personid, bounds) %>%
unique() %>%
rename(personid=x, timecat=y) %>%
arrange(personid, timecat) %>%
#take all unique combinations of people and time categories
merge(dat, by=c("personid", "timecat"), all=TRUE) %>%
mutate(fail = ifelse(is.na(fail), 0, fail)) %>%
#add fail column
group_by(personid) %>%
mutate(maxtimecat = (timecat)[!is.na(nctdel)],
atrisk = (timecat <= maxtimecat)) %>%
filter(atrisk) %>%
#for each person, identify rows where persons are not at risk (after they fail/drop out), and remove those rows
select(personid, timecat, fail) %>%
as.data.frame()
#code to add predictors of race, gender, and number of symptoms
datcat <- merge(datcat, dat, by="personid", all=T) %>%
mutate(symptom = as.factor(symptom), race = as.factor(race), gender = as.factor(gender)) %>%
select(personid, timecat = timecat.x, fail = fail.x, symptom, race, gender)
#code to add indicator effects of every timeunit
Xmat <- array(0, c(nrow(datcat), length(bounds)))
previd <- NA
changes <- c(diff(datcat$personid), 1) #a 1 marks the final index of each personid
counts <- data.frame(x = datcat$personid) %>% group_by(x) %>% mutate(n=n()) %>% '[['("n")
for(r in 1:nrow(datcat)){
if(datcat$fail[r] == 1 & changes[r] == 1){
Xmat[r,counts[r]] <- 1
}
}
colnames(Xmat) <- paste0("X",1:ncol(Xmat))
datcat <- cbind(datcat, Xmat)
#take all unique combinations of people and time categories
apply(datcat,2,typeof)
head(datcat)
apply(Xmat,2,typeof)
apply(dat,2,typeof)
datcat <- merge(datcat, dat, by="personid", all=T) %>%
mutate(symptom = as.factor(symptom), race = as.factor(race), gender = as.factor(gender), personid = as.integer(personid), timecat = as.integer(timecat), fail = as.integer(fail)) %>%
select(personid, timecat = timecat.x, fail = fail.x, symptom, race, gender)
lower_bound <- function(x, bounds){
ret <- rep(NA, length(x))
for(i in 1:length(x)){
xi <- x[i]
found <- (which(xi >= c(-Inf, bounds) & (xi <= c(bounds, Inf))))[1] - 1
if(found==0){found<-1}
ret[i] <- bounds[found]
}
return(ret)
}
bounds <- seq(0, floor(max(dat$nctdel)))
dat$timecat <- lower_bound(dat$nctdel, bounds)
dat$personid <- 1:nrow(dat)
datcat <- merge(dat$personid, bounds) %>%
unique() %>%
rename(personid=x, timecat=y) %>%
arrange(personid, timecat) %>%
#take all unique combinations of people and time categories
merge(dat, by=c("personid", "timecat"), all=TRUE) %>%
mutate(fail = ifelse(is.na(fail), 0, fail)) %>%
#add fail column
group_by(personid) %>%
mutate(maxtimecat = (timecat)[!is.na(nctdel)],
atrisk = (timecat <= maxtimecat)) %>%
filter(atrisk) %>%
#for each person, identify rows where persons are not at risk (after they fail/drop out), and remove those rows
select(personid, timecat, fail) %>%
as.data.frame()
#code to add predictors of race, gender, and number of symptoms
datcat <- merge(datcat, dat, by="personid", all=T) %>%
mutate(symptom = as.factor(symptom), race = as.factor(race), gender = as.factor(gender), personid = as.integer(personid), timecat = as.integer(timecat), fail = as.integer(fail)) %>%
select(personid, timecat = timecat.x, fail = fail.x, symptom, race, gender)
lower_bound <- function(x, bounds){
ret <- rep(NA, length(x))
for(i in 1:length(x)){
xi <- x[i]
found <- (which(xi >= c(-Inf, bounds) & (xi <= c(bounds, Inf))))[1] - 1
if(found==0){found<-1}
ret[i] <- bounds[found]
}
return(ret)
}
bounds <- seq(0, floor(max(dat$nctdel)))
dat$timecat <- lower_bound(dat$nctdel, bounds)
dat$personid <- 1:nrow(dat)
datcat <- merge(dat$personid, bounds) %>%
unique() %>%
rename(personid=x, timecat=y) %>%
arrange(personid, timecat) %>%
#take all unique combinations of people and time categories
merge(dat, by=c("personid", "timecat"), all=TRUE) %>%
mutate(fail = ifelse(is.na(fail), 0, fail)) %>%
#add fail column
group_by(personid) %>%
mutate(maxtimecat = (timecat)[!is.na(nctdel)],
atrisk = (timecat <= maxtimecat)) %>%
filter(atrisk) %>%
#for each person, identify rows where persons are not at risk (after they fail/drop out), and remove those rows
select(personid, timecat, fail) %>%
as.data.frame()
dat$race = "Other"
dat$race[dat$black==1|dat$hisp==1 ]="Black or Hispanic"
dat$gender = "male"
dat$gender[dat$male==0]="female"
dat$symptom = "0"
dat$symptom[dat$sn1==1]="1"
dat$symptom[dat$sn2==1]="2"
dat$symptom[dat$sn3==1|dat$all4==1]="3+"
dat$scan="not scanned"
dat$scan[dat$fail==1]="scanned"
dat = dat %>% group_by(race) %>% mutate(racescan = ifelse(fail == 1, mean(fail), 1-mean(fail)))
dat = dat %>% group_by(symptom) %>% mutate(symptomscan = ifelse(fail == 1, mean(fail), 1-mean(fail)))
dat = dat %>% group_by(gender) %>% mutate(genderscan = ifelse(fail == 1, mean(fail), 1-mean(fail))) %>% as.data.frame()
dat$race = "Other"
dat$race[dat$black==1|dat$hisp==1 ]="Black or Hispanic"
dat$gender = "male"
dat$gender[dat$male==0]="female"
dat$symptom = "0"
dat$symptom[dat$sn1==1]="1"
dat$symptom[dat$sn2==1]="2"
dat$symptom[dat$sn3==1|dat$all4==1]="3+"
dat$scan="not scanned"
dat$scan[dat$fail==1]="scanned"
dat = dat %>% group_by(race) %>% mutate(racescan = ifelse(fail == 1, mean(fail), 1-mean(fail)))
dat = dat %>% group_by(symptom) %>% mutate(symptomscan = ifelse(fail == 1, mean(fail), 1-mean(fail)))
dat = dat %>% group_by(gender) %>% mutate(genderscan = ifelse(fail == 1, mean(fail), 1-mean(fail))) %>% as.data.frame()
lower_bound <- function(x, bounds){
ret <- rep(NA, length(x))
for(i in 1:length(x)){
xi <- x[i]
found <- (which(xi >= c(-Inf, bounds) & (xi <= c(bounds, Inf))))[1] - 1
if(found==0){found<-1}
ret[i] <- bounds[found]
}
return(ret)
}
bounds <- seq(0, floor(max(dat$nctdel)))
dat$timecat <- lower_bound(dat$nctdel, bounds)
dat$personid <- 1:nrow(dat)
datcat <- merge(dat$personid, bounds) %>%
unique() %>%
rename(personid=x, timecat=y) %>%
arrange(personid, timecat) %>%
#take all unique combinations of people and time categories
merge(dat, by=c("personid", "timecat"), all=TRUE) %>%
mutate(fail = ifelse(is.na(fail), 0, fail)) %>%
#add fail column
group_by(personid) %>%
mutate(maxtimecat = (timecat)[!is.na(nctdel)],
atrisk = (timecat <= maxtimecat)) %>%
filter(atrisk) %>%
#for each person, identify rows where persons are not at risk (after they fail/drop out), and remove those rows
select(personid, timecat, fail) %>%
as.data.frame()
apply(dat,2,typeof)
apply(dat,2,class)
dat[[1]]
typeof(dat[[1]])
typeof(dat[1])
for(i in 1:nrow(dat)){}
for(i in 1:nrow(dat)){
typeof(dat[[i]])
}
for(i in 1:ncol(dat)){
typeof(dat[[i]])
}
for(i in 1:ncol(dat)){
print(typeof(dat[[i]]))
}
for(i in 1:ncol(dat)){
cat(names(dat)[i], "\t", typeof(dat[[i]]), "\n")
}
for(i in 1:ncol(dat)){
cat(names(dat)[i], "\t\t", typeof(dat[[i]]), "\n")
}
merge(datcat, dat, by="personid", all=T) %>%
mutate(symptom = as.factor(symptom), race = as.factor(race), gender = as.factor(gender), personid = as.integer(personid), timecat = as.integer(timecat), fail = as.integer(fail)) %>%
select(personid, timecat = timecat.x, fail = fail.x, symptom, race, gender)
merge(datcat, dat, by="personid", all=T) %>%
mutate(symptom = as.factor(symptom), race = as.factor(race), gender = as.factor(gender), personid = as.integer(personid), timecat = as.integer(timecat), fail = as.integer(fail)) %>%
select(personid, timecat = timecat.x, fail = fail.x, symptom, race, gender)
%>% head()
merge(datcat, dat, by="personid", all=T) %>%
mutate(symptom = as.factor(symptom), race = as.factor(race), gender = as.factor(gender), personid = as.integer(personid), timecat = as.integer(timecat), fail = as.integer(fail)) %>%
select(personid, timecat = timecat.x, fail = fail.x, symptom, race, gender) %>% head()
datcat <- merge(datcat, dat, by="personid", all=T) %>% head()
merge(datcat, dat, by="personid", all=T) %>%
mutate(symptom = as.factor(symptom), race = as.factor(race), gender = as.factor(gender), personid = as.integer(personid), timecat = as.integer(timecat), fail = as.integer(fail)) %>%
select(personid, timecat = timecat.x, fail = fail.x, symptom, race, gender) %>% head()
merge(datcat, dat, by="personid", all=T) %>% head()
lower_bound <- function(x, bounds){
ret <- rep(NA, length(x))
for(i in 1:length(x)){
xi <- x[i]
found <- (which(xi >= c(-Inf, bounds) & (xi <= c(bounds, Inf))))[1] - 1
if(found==0){found<-1}
ret[i] <- bounds[found]
}
return(ret)
}
bounds <- seq(0, floor(max(dat$nctdel)))
dat$timecat <- lower_bound(dat$nctdel, bounds)
dat$personid <- 1:nrow(dat)
datcat <- merge(dat$personid, bounds) %>%
unique() %>%
rename(personid=x, timecat=y) %>%
arrange(personid, timecat) %>%
#take all unique combinations of people and time categories
merge(dat, by=c("personid", "timecat"), all=TRUE) %>%
mutate(fail = ifelse(is.na(fail), 0, fail)) %>%
#add fail column
group_by(personid) %>%
mutate(maxtimecat = (timecat)[!is.na(nctdel)],
atrisk = (timecat <= maxtimecat)) %>%
filter(atrisk) %>%
#for each person, identify rows where persons are not at risk (after they fail/drop out), and remove those rows
select(personid, timecat, fail) %>%
as.data.frame()
merge(datcat, dat, by="personid", all=T) %>% head()
merge(datcat, dat, by="personid", all=T) %>%
mutate(symptom = as.factor(symptom), race = as.factor(race), gender = as.factor(gender), personid = as.integer(personid), timecat = as.integer(timecat.x), fail = as.integer(fail.x)) %>%
select(personid, timecat = timecat, fail = fail, symptom, race, gender)
merge(datcat, dat, by="personid", all=T) %>%
mutate(symptom = as.factor(symptom), race = as.factor(race), gender = as.factor(gender), personid = as.integer(personid), timecat = as.integer(timecat.x), fail = as.integer(fail.x)) %>%
select(personid, timecat = timecat, fail = fail, symptom, race, gender)
datcat <- merge(datcat, dat, by="personid", all=T) %>%
mutate(symptom = as.factor(symptom), race = as.factor(race), gender = as.factor(gender), personid = as.integer(personid), timecat = as.integer(timecat.x), fail = as.integer(fail.x)) %>%
select(personid, timecat = timecat, fail = fail, symptom, race, gender)
for(i in 1:ncol(datcat)){
cat(names(datcat)[i], "\t", typeof(datcat[[i]]), "\n")
}
head(datcat)
Xmat <- array(0, c(nrow(datcat), length(bounds)))
previd <- NA
changes <- c(diff(datcat$personid), 1) #a 1 marks the final index of each personid
counts <- data.frame(x = datcat$personid) %>% group_by(x) %>% mutate(n=n()) %>% '[['("n")
for(r in 1:nrow(datcat)){
if(datcat$fail[r] == 1 & changes[r] == 1){
Xmat[r,counts[r]] <- 1
}
}
colnames(Xmat) <- paste0("X",1:ncol(Xmat))
datcat <- cbind(datcat, Xmat)
for(i in 1:ncol(datcat)){
cat(names(datcat)[i], "\t", typeof(datcat[[i]]), "\n")
}
logreg1 <- glm(fail ~ . - personid, data=datcat, family="binomial") #does not converge
indepcols <- which(!colnames(datcat) %in% c("fail", "personid"))
lassoreg1 <- glmnet(y=datcat$fail, x = datcat[,indepcols], family="binomial", alpha = 1)
lassoreg1 <- glmnet(y=datcat$fail, x = datcat[,indepcols], family="binomial", alpha = 1)
lassoreg1 <- glmnet(y=datcat$fail, x = as.matrix(datcat[,indepcols]), family="binomial", alpha = 1)
View(as.matrix(datcat[,indepcols]))
paste0("X", 0:27)
lassoreg1 <- glmnet(y=datcat$fail, x = datcat[,paste0("X", 0:27)], family="binomial", alpha = 1)
datcat[,paste0("X", 1:26)]
lassoreg1 <- glmnet(y=datcat$fail, x = datcat[,paste0("X", 1:26)], family="binomial", alpha = 1)
lassoreg1 <- glmnet(y=datcat$fail, x = as.matrix(datcat[,paste0("X", 1:26)]), family="binomial", alpha = 1)
ridgereg1 <- glmnet(y=datcat$fail, x = as.matrix(datcat[,indepcols]_, family="binomial", alpha = 0)
ridgereg1 <- glmnet(y=datcat$fail, x = as.matrix(datcat[,indepcols]), family="binomial", alpha = 0)
lassoreg1 <- glmnet(y=datcat$fail, x = as.matrix(datcat[,paste0("X", 1:26)]), family="binomial", alpha = 1)
apply(datcat, 2, typeof)
head(datcat[[1]])
head(datcat[["symptom"]])
head(datcat[["race"]])
head(datcat[["gender"]])
colnames(datcat[indepcols])
plot(dat.KM, main=expression(paste("Kaplan-Meier Estimate ", hat(S)(t), " with CI")),
xlab="t", ylab="Survival", lwd=2)
plot(dat.KM, main=expression(paste("Kaplan-Meier Estimate ", hat(S)(t), " with CI")),
xlab="t", ylab="Survival", lwd=2)
dat.KM <- survfit(Surv(nctdel, fail) ~ 1, data = dat) #estimated survival curve
plot(dat.KM, main=expression(paste("Kaplan-Meier Estimate ", hat(S)(t), " with CI")),
xlab="t", ylab="Survival", lwd=2)
dat <- read.table("kellydat.txt", header=T)
dat$race = "Other"
dat$race[dat$black==1|dat$hisp==1 ]="Black or Hispanic"
dat$gender = "male"
dat$gender[dat$male==0]="female"
dat$symptom = "0"
dat$symptom[dat$sn1==1]="1"
dat$symptom[dat$sn2==1]="2"
dat$symptom[dat$sn3==1|dat$all4==1]="3+"
dat$scan="not scanned"
dat$scan[dat$fail==1]="scanned"
dat = dat %>% group_by(race) %>% mutate(racescan = ifelse(fail == 1, mean(fail), 1-mean(fail)))
dat = dat %>% group_by(symptom) %>% mutate(symptomscan = ifelse(fail == 1, mean(fail), 1-mean(fail)))
dat = dat %>% group_by(gender) %>% mutate(genderscan = ifelse(fail == 1, mean(fail), 1-mean(fail))) %>% as.data.frame()
set.seed(440)
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message=FALSE)
library(ggplot2)
library(survival)
library(gridExtra)
library(dplyr)
library(survminer)
library(reshape2)
library(glmnet)
library(arm)
dat <- read.table("kellydat.txt", header=T)
dat$race = "Other"
dat$race[dat$black==1|dat$hisp==1 ]="Black or Hispanic"
dat$gender = "male"
dat$gender[dat$male==0]="female"
dat$symptom = "0"
dat$symptom[dat$sn1==1]="1"
dat$symptom[dat$sn2==1]="2"
dat$symptom[dat$sn3==1|dat$all4==1]="3+"
dat$scan="not scanned"
dat$scan[dat$fail==1]="scanned"
dat = dat %>% group_by(race) %>% mutate(racescan = ifelse(fail == 1, mean(fail), 1-mean(fail)))
dat = dat %>% group_by(symptom) %>% mutate(symptomscan = ifelse(fail == 1, mean(fail), 1-mean(fail)))
dat = dat %>% group_by(gender) %>% mutate(genderscan = ifelse(fail == 1, mean(fail), 1-mean(fail))) %>% as.data.frame()
dat.KM <- survfit(Surv(nctdel, fail) ~ 1, data = dat) #estimated survival curve
plot(dat.KM, main=expression(paste("Kaplan-Meier Estimate ", hat(S)(t), " with CI")),
xlab="t", ylab="Survival", lwd=2)
head(datcat)
head(datcat_X)
lower_bound <- function(x, bounds){
ret <- rep(NA, length(x))
for(i in 1:length(x)){
xi <- x[i]
found <- (which(xi >= c(-Inf, bounds) & (xi <= c(bounds, Inf))))[1] - 1
if(found==0){found<-1}
ret[i] <- bounds[found]
}
return(ret)
}
de_logit <- function(logodds){
o <- exp(logodds)
p <- o/(1+o)
return(p)
}
bounds <- 1:5
dat$timecat <- as.integer(as.factor(lower_bound(dat$nctdel, bounds)))
dat$personid <- 1:nrow(dat)
datcat <- merge(dat$personid, bounds) %>%
unique() %>%
mutate(personid=x, timecat=as.integer(as.factor(y))) %>%
arrange(personid, timecat) %>%
#take all unique combinations of people and time categories
merge(dat, by=c("personid", "timecat"), all=TRUE) %>%
mutate(fail = ifelse(is.na(fail), 0, fail)) %>%
#add fail column
group_by(personid) %>%
mutate(maxtimecat = (timecat)[!is.na(nctdel)],
atrisk = (timecat <= maxtimecat)) %>%
filter(atrisk) %>%
#for each person, identify rows where persons are not at risk (after they fail/drop out), and remove those rows
dplyr::select(personid, timecat, fail) %>%
as.data.frame()
#code to add predictors of race, gender, and number of symptoms
datcat <- merge(datcat, dat, by="personid", all=T) %>%
mutate(symptom0 = ifelse(symptom == 0, 1, 0),
symptom1 = ifelse(symptom == 1, 1, 0),
symptom2 = ifelse(symptom == 2, 1, 0),
raceother = ifelse(race == "Other", 1, 0),
male = ifelse(gender == "male", 1, 0),
personid = as.integer(personid),
timecat = as.integer(timecat.x),
fail = as.integer(fail.x)) %>%
dplyr::select(personid, timecat = timecat, fail = fail, symptom0, symptom1, symptom2, raceother, male)
#code to add indicator effects of every timeunit
Xmat <- array(0, c(nrow(datcat), length(bounds)))
# previd <- NA
# changes <- c(diff(datcat$personid), 1) #a 1 marks the final index of each personid
# counts <- data.frame(x = datcat$personid) %>% group_by(x) %>% mutate(n=n()) %>% '[['("n")
for(r in 1:nrow(datcat)){
Xmat[r,datcat$timecat[r]] <- 1
}
colnames(Xmat) <- paste0("X",1:ncol(Xmat))
datcat_X <- (cbind((datcat), Xmat))
nullmod <- glm(fail ~ 1, data=datcat_X, family="binomial")
logistic_diagnostics <- function(mod=NA, ydat=y, Xdat=X){
if(class(mod) == "cv.glmnet"){
fitvals <- predict.cv.glmnet(mod, newx = Xdat, s="lambda.min")
}else{
fitvals <- predict.glm(mod, newdata=data.frame(Xdat))
}
p_hat <- de_logit(fitvals)
resids_p <- (ydat-p_hat)/(sqrt(p_hat*(1-p_hat)))
s <- ydat; s[ydat==0] <- -1
resids_d <- s*sqrt(-2*(ydat*log(p_hat) + (1-ydat)*log(1-p_hat)))
resids_p_stat <- sum(resids_p^2)
resids_d_stat <- -2*sum(ydat*log(p_hat) + (1-ydat)*log(1-p_hat))
p <- sum(as.matrix(coef(mod)) != 0)
dof <- nrow(Xdat)-p
return(list(p_hat = p_hat, resids_p=resids_p, resids_p_stat=resids_p_stat, resids_d=resids_d, resids_d_stat=resids_d_stat, dof=dof))
}
indepcols <- which(!colnames(datcat_X) %in% c("fail", "personid", "timecat"))
X <- as.matrix(datcat_X[,indepcols])
y <- datcat_X$fail
#0 means no incercept
logmod <- glm(y ~ 0 + X, family="binomial")
logmod_stats <- logistic_diagnostics(logmod)
logmodtest <- pchisq(logmod$deviance, logmod$df.residual, lower=FALSE)
lassomod <- cv.glmnet(y=y, x = X, family="binomial", type.measure="class", alpha = 1, intercept=FALSE)
lassomod_stats <- logistic_diagnostics(lassomod)
lassomodtest <- pchisq(lassomod_stats$resids_d_stat, lassomod_stats$dof, lower=FALSE)
ridgemod <- cv.glmnet(y=y, x = X, family="binomial", type.measure="class", alpha = 0,intercept=FALSE)
ridgemod_stats <- logistic_diagnostics(ridgemod)
ridgemodtest <- pchisq(ridgemod_stats$resids_d_stat, ridgemod_stats$dof, lower=FALSE)
#evaluating deviance of models. small p-value = lack of fit
par((mfrow = c(3,1)))
binnedplot(x=logmod$fitted.values, y=logmod_stats$resids_d, main = "OLS Logistic Regression Binned Residuals", ylab = "Deviance Residuals", xlab = "Fitted Values")
binnedplot(x=lassomod_stats$p_hat, y=lassomod_stats$resids_d, main = "LASSO Logistic Regression Binned Residuals", ylab = "Deviance Residuals", xlab = "Fitted Values")
binnedplot(x=ridgemod_stats$p_hat, y=ridgemod_stats$resids_p, main = "Ridge Logistic Regression Binned Residuals", ylab = "Deviance Residuals", xlab = "Fitted Values")
head(dat)
head(datcat)
coef(glm)
coef(logmod)
data.frame(logmodtest, lassomodtest, ridgemodtest)
t(data.frame(logmodtest, lassomodtest, ridgemodtest))
library(knitr)
kable(t(data.frame(logmodtest, lassomodtest, ridgemodtest)))
d <- matrix(c(logmodtest, lassomodtest, ridgemodtest))
matrix(c(logmodtest, lassomodtest, ridgemodtest))
d
d <- matrix(c(logmodtest, lassomodtest, ridgemodtest))
colnames(d) <- "p-value"
rownames(d) <- c("Ordinary Least Squares", "LASSO Penalty", "Ridge Penalty")
d <- matrix(c(logmodtest, lassomodtest, ridgemodtest))
colnames(d) <- "p-value"
rownames(d) <- c("Ordinary Least Squares", "LASSO Penalty", "Ridge Penalty")
d
kable(d)
warnings()
